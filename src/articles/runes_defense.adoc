---
title: "Svelte 5: Coming Around to Runes"
date: "2023-10-20"
published: false
categories:
  - svelte
  - web
  - frontend
---

:toc:

// TODO: Svelte signals docs
:link1: https://example.com

== Introduction

When I first learned about Svelte 5, I was very resistant. I had originally fallen in love with Svelte for its simplicity--how the compiler allowed me to basically just write HTML and JavaScript. The first thing I pointed to when recommending it to others was its implicit reactivity. No more useState all over the damn place, just declare a variable and stop thinking so hard. I became attached to this single feature of Svelte, and a tie formed in my mind between this and Svelte's simplicity as a whole. Of course, implicit reactivity wasn't what made Svelte Svelte. It was among the first things you noticed, sure, but it existed in a sea of other features, such as its html-first syntax, native TypeScript support, and simple component creation. Nevertheless, when I saw the introduction of the $state rune, I was scared. It was too similar to Svelte's competitors; it felt like a step in the wrong direction, away from made Svelte so great. However, what I failed to see is that the reduced simplicity ultimately led to countless benefits, and the addition of runes actually served to further the principles that set Svelte apart in the web frontend ecosystem. I was resistant to runes for a long time, until I eventually decided to try them out myself and migrated this site to Svelte 5. As I started to work more with the various available runes, I found myself growing more agreeable to the idea.

Why was it so hard for me to get comfortable with runes? What eventually made me change my mind? That's the subject of today's investigation.

== Explicit Reactivity

Like I described in the introduction, Svelte's implicit reactivity was its main draw for most web developers. However, there is a decent argument to be made that it ultimately was a detriment to the framework, making large codebases harder to follow. $state, while eerily similar to react, isn't actually all that crazy. All it changes for the developer is how reactive state is initialized. All the rest of the code stays exactly the same. $state actually offers some under-the-hood improvements by {link1}[introducing signals to Svelte], but I'm focusing on DX today. Really, the best way to understand that it's not that bad is to just try it out. It's pretty hard to argue about DX for a change this small. My main point in favor of $state is that semantics really do matter. Having explicit declarations of reactivity makes a codebase more robust.

== .svelte.ts and .svelte.js

Another thing that runes allow for is using Svelte code in JavaScript and TypeScript files. This opens up countless possibilities for Svelte libraries, as well as (arguably) improving the DX for shared state. Admittedly, using getter and setter functions to replicate the functionality of stores is a little obtuse at first. Being able to work with stores as though they were variables by preceding them with a dollar sign was kind of nice, but it nevertheless made things a little messy. Using getters and setters in combination with the $state rune not only unifies how reactivity works (it's $state everywhere), but also allows for the variable to be consumed without any special syntax.

[source,svelte]
----
<!-- before -->
<script>
  import {theme} from '$lib/stores';
</script>

<p>theme: {$theme}</p>

<!-- after -->
<script>
  import store from '$lib/store.svelte';
</script>

<p>theme: {store.theme}</p>
----


== Separation of Concerns

The $ used to denote a reactive statement. However, it was the only way to accomplish two very different things: derived state and side effects. The new $derived and $effect runes now separate these two behaviors and make their use explicit. This is yet another example of runes increasing semantic explicitness in Svelte where it was desperately needed.
